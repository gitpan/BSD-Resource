head	1.11;
access;
symbols;
locks; strict;
comment	@# @;


1.11
date	96.02.17.14.14.02;	author jhi;	state Exp;
branches;
next	1.10;

1.10
date	95.12.18.09.57.41;	author jhi;	state Exp;
branches;
next	1.9;

1.9
date	95.12.18.08.31.47;	author jhi;	state Exp;
branches;
next	1.8;

1.8
date	95.12.07.19.33.47;	author jhi;	state Exp;
branches;
next	1.7;

1.7
date	95.12.07.16.29.33;	author jhi;	state Exp;
branches;
next	1.6;

1.6
date	95.12.06.15.54.02;	author jhi;	state Exp;
branches;
next	1.5;

1.5
date	95.11.18.15.55.48;	author jhi;	state Exp;
branches;
next	1.4;

1.4
date	95.11.18.15.46.50;	author jhi;	state Exp;
branches;
next	1.3;

1.3
date	95.11.18.13.49.04;	author jhi;	state Exp;
branches;
next	1.2;

1.2
date	95.11.18.13.31.40;	author jhi;	state Exp;
branches;
next	1.1;

1.1
date	95.11.18.13.29.31;	author jhi;	state Exp;
branches;
next	;


desc
@@


1.11
log
@"rlim_t" is now unsigned long instead of double.
sv_2mortal() removed as unnecessary.
@
text
@/*
 * Copyright (c) 1995 Jarkko Hietaniemi. All rights reserved.
 * This program is free software; you can redistribute it and/or
 * modify it under the same terms as Perl itself.
 *
 * Time-stamp:	<96/02/17 16:09:30 jhi>
 *
 * $Id: Resource.xs,v 1.10 1995/12/18 09:57:41 jhi Exp jhi $
 *
 */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* if this fails your vendor has failed you and Perl cannot help */
#include <sys/resource.h>

#if defined(__sun__) && defined(__svr4__)
#include <sys/rusage.h>
/* Solaris has no RUSAGE_* defined in <sys/resource.h>, ugh.
 * There is <sys/rusage.h> which has but this file is very non-standard.
 * More the fun, the file itself warns will not be there for long.
 * Thank you, Sun. */
#define SOLARIS
#define part_of_sec tv_nsec
#define part_in_sec 0.000001
/* Solaris uses timerstruc_t in struct rusage. According to the <sys/time.h>
 * tv_nsec in the timerstruc_t is nanoseconds (and the name also supports
 * that theory) BUT getrusage() seems to tick microseconds, not nano.
 * Amazing, Sun. */
#endif

#ifdef I_SYS_TIME
#   include <sys/time.h>
#endif

#ifdef I_SYS_SELECT
#   include <sys/select.h>	/* struct timeval might be hidden in here */
#endif

#ifndef part_of_sec
#define part_of_sec tv_usec
#define part_in_sec 0.000001
#endif

#define IDM ((double)part_in_sec)
#define TV2DS(tv) ((double)tv.tv_sec+(double)tv.part_of_sec*part_in_sec)

#ifndef HAS_GETRUSAGE
#  if defined(RUSAGE_SELF) || defined(SOLARIS)
#     define HAS_GETRUSAGE
#  endif
#endif

#if defined(__hpux)
/* there is getrusage() in HPUX but only as an indirect syscall */
#   define try_getrusage_as_syscall
/* some rlimits exist (but are officially unsupported by HP) */
#   define RLIMIT_CPU      0
#   define RLIMIT_FSIZE    1
#   define RLIMIT_DATA     2
#   define RLIMIT_STACK    3
#   define RLIMIT_CORE     4
#   define RLIMIT_RSS      5
#   define RLIMIT_NOFILE   6
#   define RLIMIT_OPEN_MAX RLIMIT_NOFILE
#   define RLIM_NLIMITS    7
#   define RLIM_INFINITY   0x7fffffff
#endif

#ifdef try_getrusage_as_syscall
#   include <sys/syscall.h>
#   if defined(SYS_GETRUSAGE)
#       define getrusage(a, b)	syscall(SYS_GETRUSAGE, (a), (b))
#	define HAS_GETRUSAGE
#   endif
#endif

#if defined(RLIM_INFINITY)	/* this is the only one we can count on (?) */
#define HAS_GETRLIMIT
#define HAS_SETRLIMIT
#endif

#if defined(PRIO_USER)
#define HAS_GETPRIORITY
#define HAS_SETPRIORITY
#endif

#ifndef HAS_GETPRIORITY
#define getpriority(a) not_here("getpriority")
#endif

#ifndef HAS_GETRLIMIT
#define getrlimit(a) not_here("getrlimit")
#endif

#ifndef HAS_GETRUSAGE
#define getrusage(a) not_here("getrusage")
#endif

#ifndef HAS_SETPRIORITY
#define setpriority(a) not_here("setpriority")
#endif

#ifndef HAS_SETRLIMIT
#define setrlimit(a,b,c) not_here("setrlimit")
#endif

static int
not_here(s)
char *s;
{
    croak("BSD::Resource::%s not implemented on this architecture", s);
    return -1;
}

static double
constant(name, arg)
char *name;
int arg;
{
    errno = 0;
    switch (*name) {
    case 'P':
	if (strnEQ(name, "PRIO_", 4)) {
	    if (strEQ(name, "PRIO_MIN"))
#ifdef PRIO_MIN
		return PRIO_MIN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "PRIO_MAX"))
#ifdef PRIO_MAX
		return PRIO_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "PRIO_USER"))
#ifdef PRIO_USER
		return PRIO_USER;
#else
		goto not_there;
#endif
	    if (strEQ(name, "PRIO_PGRP"))
#ifdef PRIO_PGRP
		return PRIO_PGRP;
#else
		goto not_there;
#endif
	    if (strEQ(name, "PRIO_PROCESS"))
#ifdef PRIO_PROCESS
		return PRIO_PROCESS;
#else
		goto not_there;
#endif
	}
    goto not_there;
    case 'R':
	if (strnEQ(name, "RLIM", 4)) {
	    if (strEQ(name, "RLIMIT_CPU"))
#ifdef RLIMIT_CPU
		return RLIMIT_CPU;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_FSIZE"))
#ifdef RLIMIT_FSIZE
		return RLIMIT_FSIZE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_DATA"))
#ifdef RLIMIT_DATA
		return RLIMIT_DATA;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_NOFILE"))
#ifdef RLIMIT_NOFILE
		return RLIMIT_NOFILE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_OPEN_MAX"))
#ifdef RLIMIT_OPEN_MAX
		return RLIMIT_OPEN_MAX;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_AS"))
#ifdef RLIMIT_AS
		return RLIMIT_AS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_VMEM"))
#ifdef RLIMIT_VMEM
		return RLIMIT_VMEM;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_STACK"))
#ifdef RLIMIT_STACK
		return RLIMIT_STACK;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_CORE"))
#ifdef RLIMIT_CORE
		return RLIMIT_CORE;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIMIT_RSS"))
#ifdef RLIMIT_RSS
		return RLIMIT_RSS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIM_NLIMITS"))
#ifdef RLIM_NLIMITS
		return RLIM_NLIMITS;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RLIM_INFINITY"))
#ifdef RLIM_INFINITY
		return RLIM_INFINITY;
#else
		goto not_there;
#endif
	    break;
	 }
	if (strnEQ(name, "RUSAGE_", 7)) {
	    if (strEQ(name, "RUSAGE_SELF"))
#ifdef RUSAGE_SELF
		return RUSAGE_SELF;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RUSAGE_CHILDREN"))
#ifdef RUSAGE_CHILDREN
		return RUSAGE_CHILDREN;
#else
		goto not_there;
#endif
	    if (strEQ(name, "RUSAGE_THREAD"))
#ifdef RUSAGE_THREAD
		return RUSAGE_THREAD;
#else
		goto not_there;
#endif
	    break;
	 }
    goto not_there;

    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
    }
}

MODULE = BSD::Resource		PACKAGE = BSD::Resource

double
constant(name,arg)
	char *		name
	int		arg

int
getpriority(which,who)
	int		which
	int		who

int
getrlimit(resource)
	int		resource
    PPCODE:
	struct rlimit buf;
	if (getrlimit(resource,&buf) >= 0) {
	    EXTEND(sp, 2);
	    PUSHs(newSViv((unsigned long)buf.rlim_cur));
	    PUSHs(newSViv((unsigned long)buf.rlim_max));
	}

int
getrusage(who)
	int		who
    PPCODE:
	struct rusage buf;
	if (getrusage(who,&buf) >= 0) {
	    EXTEND(sp, 16);
	    PUSHs(newSVnv(TV2DS(buf.ru_utime)));
	    PUSHs(newSVnv(TV2DS(buf.ru_stime)));
	    PUSHs(newSViv((I32)buf.ru_maxrss));
	    PUSHs(newSViv((I32)buf.ru_ixrss));
	    PUSHs(newSViv((I32)buf.ru_idrss));
	    PUSHs(newSViv((I32)buf.ru_isrss));
	    PUSHs(newSViv((I32)buf.ru_minflt));
	    PUSHs(newSViv((I32)buf.ru_majflt));
	    PUSHs(newSViv((I32)buf.ru_nswap));
	    PUSHs(newSViv((I32)buf.ru_inblock));
	    PUSHs(newSViv((I32)buf.ru_oublock));
	    PUSHs(newSViv((I32)buf.ru_msgsnd));
	    PUSHs(newSViv((I32)buf.ru_msgrcv));
	    PUSHs(newSViv((I32)buf.ru_nsignals));
	    PUSHs(newSViv((I32)buf.ru_nvcsw));
	    PUSHs(newSViv((I32)buf.ru_nivcsw));
	}

int
setpriority(which,who,priority)
	int		which
	int		who
	int		priority
    CODE:
	RETVAL = setpriority(which,who,priority) == 0 ? 1 : 0;
    OUTPUT:
	RETVAL

int
setrlimit(resource,soft,hard)
	int		resource
	unsigned long	soft
	unsigned long	hard
    CODE:
	struct rlimit buf;
	buf.rlim_cur = soft;
	buf.rlim_max = hard;
	RETVAL = setrlimit(resource,&buf) == 0 ? 1 : 0;
    OUTPUT:
	RETVAL
@


1.10
log
@setrlimit(), RLIM_INFINITY.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/12/18 11:53:30 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.9 1995/12/18 08:31:47 jhi Exp jhi $
d286 2
a287 2
	    PUSHs(sv_2mortal(newSVnv(buf.rlim_cur)));
	    PUSHs(sv_2mortal(newSVnv(buf.rlim_max)));
d297 16
a312 16
	    PUSHs(sv_2mortal(newSVnv(TV2DS(buf.ru_utime))));
	    PUSHs(sv_2mortal(newSVnv(TV2DS(buf.ru_stime))));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_maxrss)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_ixrss)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_idrss)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_isrss)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_minflt)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_majflt)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_nswap)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_inblock)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_oublock)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_msgsnd)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_msgrcv)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_nsignals)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_nvcsw)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.ru_nivcsw)));
d328 2
a329 2
	double		soft
	double		hard
d332 2
a333 2
	buf.rlim_cur = (int) soft;
	buf.rlim_max = (int) hard;
@


1.9
log
@Solaris 'portability'.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/12/07 21:31:13 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.8 1995/12/07 19:33:47 jhi Exp jhi $
d286 2
a287 2
	    PUSHs(sv_2mortal(newSViv((I32)buf.rlim_cur)));
	    PUSHs(sv_2mortal(newSViv((I32)buf.rlim_max)));
d328 2
a329 2
	int		soft
	int		hard
d332 2
a333 2
	buf.rlim_cur = soft;
	buf.rlim_max = hard;
@


1.8
log
@RLIM 4. no need for double in setrlimit().
@
text
@d8 1
a8 1
 * $Id: Resource.xs,v 1.7 1995/12/07 16:29:33 jhi Exp jhi $
d19 15
d42 4
a45 2
#define IDM ((double)0.000001)
#define TV2DS(tv) ((double)tv.tv_sec+(double)tv.tv_usec*IDM)
d47 7
a53 2
#ifdef RUSAGE_SELF
#   define HAS_GETRUSAGE
d85 1
a85 1
#if defined(PRIO_MIN) && defined(PRIO_USER)
@


1.7
log
@croak BSD::Resource::. setrlimit() accepts doubles.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/12/07 18:11:53 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.6 1995/12/06 15:54:02 jhi Exp jhi $
d138 1
a138 1
	if (strnEQ(name, "RLIMIT_", 6)) {
d306 2
a307 2
	double		soft
	double		hard
d310 2
a311 2
	buf.rlim_cur = (int) soft;
	buf.rlim_max = (int) hard;
@


1.6
log
@RUSAGE_THREAD.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/12/06 17:47:24 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.5 1995/11/18 15:55:48 jhi Exp jhi $
d92 1
a92 1
    croak("Resource::%s not implemented on this architecture", s);
d306 2
a307 2
	int		soft
	int		hard
d310 2
a311 2
	buf.rlim_cur = soft;
	buf.rlim_max = hard;
@


1.5
log
@RLIM_{NLIMITS,INFINITY}, not RLIMIT_.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/11/18 17:55:30 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.4 1995/11/18 15:46:50 jhi Exp jhi $
d223 6
@


1.4
log
@modf() removed, HPUX *rlimit support added, OPEN_MAX, NLIMITS, added.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/11/18 16:14:25 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.3 1995/11/18 13:49:04 jhi Exp jhi $
d199 3
a201 3
	    if (strEQ(name, "RLIMIT_NLIMITS"))
#ifdef RLIMIT_NLIMITS
		return RLIMIT_NLIMITS;
d205 3
a207 3
	    if (strEQ(name, "RLIMIT_INFINITY"))
#ifdef RLIMIT_INFINITY
		return RLIMIT_INFINITY;
@


1.3
log
@hpux getrusage() was not found in time.
@
text
@d6 1
a6 1
 * Time-stamp:	<95/11/18 15:45:10 jhi>
d8 1
a8 1
 * $Id: Resource.xs,v 1.2 1995/11/18 13:31:40 jhi Exp jhi $
d16 1
a16 1
/* if you fail this, your vendor has failed you and Perl cannot help */
a26 1
#define DM ((double)1000000.0)
a29 8
#ifdef HAS_MODF
#define DS2TV(ds,tv) do{tv.tv_usec=(int)(DM*modf(ds,&tv.tv_sec)+0.1);}while(0)
#else
#define DS2TV(ds,tv) do{tv.tv_sec=(int)ds;\
			tv.tv_usec=(int)(DM*(ds-tv.tv_sec)+0.1);\
		       }while(0)
#endif

d34 1
a35 1
#if defined(__hpux)
d37 11
d53 1
a53 1
#   define getrusage(a, b)	syscall(SYS_GETRUSAGE, (a), (b))
a55 1
#   undef try_getrusage_as_syscall
d58 1
a58 1
#if defined(RLIMIT_INFINITY)	/* this is the only one we can count on (?) */
d163 6
d196 6
@


1.2
log
@set{rlimit,priority} success 1, failure 0.
@
text
@d6 3
a8 1
 * $Id: Resource.xs,v 1.1 1995/11/18 13:29:31 jhi Exp jhi $
d43 3
a45 6
#if !defined(HAS_GETRUSAGE)
#   undef try_getrusage_as_syscall
    /* there is getrusage() in HPUX but only as an indirect syscall */
#   if defined(__hpux)
#       define try_getrusage_as_syscall
#   endif
d48 5
a52 7
#if !defined(HAS_GETRUSAGE)
#   ifdef try_getrusage_as_syscall
#       include <sys/syscall.h>
#       if defined(SYS_GETRUSAGE)
#	    define getrusage(a, b)	syscall(SYS_GETRUSAGE, (a), (b))
#	    define HAS_GETRUSAGE
#	endif
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * $Id$
d282 4
d296 1
a296 1
	RETVAL = setrlimit(resource,&buf);
@
